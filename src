class CanvasHelper
	drawRect = (ctx, x, y, width, height, color) ->
		ctx.rect x, y, width, height
		ctx.fillStyle = color
		ctx.fill()

	drawRoundedRect = (ctx, x, y, width, height, color, radius) ->
		x += 0.5
		y += 0.5
		ctx.beginPath()
		ctx.arc x + radius, y + radius, radius, Math.PI, 1.5 * Math.PI
		ctx.lineTo x + width - 2 * radius, y
		ctx.arc x + width - radius, y + radius, radius, 1.5 * Math.PI, 2 * Math.PI
		ctx.lineTo x + width, y + height - radius
		ctx.arc x + width - radius, y + height - radius, radius, 0, 0.5 * Math.PI
		ctx.lineTo x + radius, y + height
		ctx.arc x + radius, y + height - radius, radius, 0.5 * Math.PI, Math.PI
		ctx.lineTo x, y + radius
		ctx.closePath()
		ctx.fillStyle = color
		ctx.fill();
		ctx.lineWidth = 1;
		ctx.strokeStyle = Sequenced.COLOR_OBJECT_BORDER;
		ctx.stroke();

	drawRightArrow = (ctx, x1, x2, y, color, fontColor, text) ->
		ctx.beginPath()
		ctx.moveTo x1, y - ArrowHandleHeight / 2
		ctx.lineTo x2 - ArrowHandleHeight, y - ArrowHandleHeight / 2
		ctx.lineTo x2 - ArrowHandleHeight, y - ArrowHandleHeight
		ctx.lineTo x2, y
		ctx.lineTo x2 - ArrowHandleHeight, y + ArrowHandleHeight
		ctx.lineTo x2 - ArrowHandleHeight, y + ArrowHandleHeight / 2
		ctx.lineTo x1, y + ArrowHandleHeight / 2
		ctx.closePath()
		ctx.fillStyle = color
		ctx.fill();

		drawWrapText ctx, text, (x1 + x2) / 2, y + fontSize / 3, x2 - x1 - fontSize

	drawLeftArrow = (ctx, x1, x2, y, color, fontColor, text) ->
		ctx.beginPath()
		ctx.moveTo x2, y - ArrowHandleHeight / 2
		ctx.lineTo x1 + ArrowHandleHeight, y - ArrowHandleHeight / 2
		ctx.lineTo x1 + ArrowHandleHeight, y - ArrowHandleHeight
		ctx.lineTo x1, y
		ctx.lineTo x1 + ArrowHandleHeight, y + ArrowHandleHeight
		ctx.lineTo x1 + ArrowHandleHeight, y + ArrowHandleHeight / 2
		ctx.lineTo x2, y + ArrowHandleHeight / 2
		ctx.closePath()
		ctx.fillStyle = color
		ctx.fill()

		drawWrapText ctx, text, (x1 + x2) / 2, y + fontSize / 3, x2 - x1 - fontSize

	drawWrapText = (ctx, text, x, y, maxWidth, isBold) ->
		ctx.font = (if isBold then 'bold ' else '') + fontSize + 'px ' + fontFamily
		ctx.textAlign = 'center'
		ctx.fillStyle = fontColor

		x += 4
		words = text.split ' '
		line = ''
		yd = 0

		for i in [0...words.length]
			testLine = line + words[i] + ' '
			metrics = ctx.measureText testLine
			testWidth = metrics.width

			if (testWidth > maxWidth and i > 0)
				yd = fontSize / 2 + 2
				ctx.fillText line, x, y - yd
				line = words[i] + ' '
				y += textLineHeight
			else
				line = testLine;

		ctx.fillText line, x, y - yd


class Sequenced
	# Globals.
	ctx = null
	colorTable = {}
	objectWidth = null
	objectHeight = null
	textLineHeight = null
	fontFamily = null
	fontColor = null
	fontSize = null

	canvasElement = null
	sequenceData = null
	columHeight = null

	# Inner Constants.
	DefaultCanvasWidth = 800
	DefaultObjectWidth = 12
	DefaultObjectHeight = 12
	DefualtLineHeight = 18
	DefaultFontFamily = 'Verdana'
	DefaultFontColor = '#000'
	DefaultFontSize = 14
	MaxObjectWidth = 150
	RowHeight = 50
	Margin = 10
	LifelineWidth = 8
	ArrowHandleHeight = 12

	# Predefined.
	@COLOR_OBJECT = [
		'#fdd9b4'
		'#bae0ec'
		'#c2e2c7'
		'#c9d1f7'
		'#e5cff4'
		'#f8cdd4'
	]

	@COLOR_OBJECT_BORDER = '#c0c0c0' #C0C0C0
	@COLOR_LIFELINE = '#80aada' #87CEFA
	@COLOR_MESSAGE = '#f7ab42' #F4A460

	@render = (canvasElementId, seqData) ->
		canvasElement = document.getElementById canvasElementId
		sequenceData = seqData

		initSequenceData()
		initCanvas()
		initVariables()

		drawObjects()

	@setColorTable = (name, color) ->
		colorTable[name] = color

	@setObjectSize = (width, height) ->
		objectWidth = width
		objectHeight = height

	@setFontFamily = (value) ->
		fontFamily = value

	@setFontSize = (value) ->
		fontSize = value

	drawObjects = ->
		objectCount = sequenceData.objects.length

		for i in [0...objectCount]
			object = sequenceData.objects[i]

			x = Margin + (DefaultCanvasWidth - objectWidth - Margin * 2) / (objectCount - 1) * i

			drawObject x, Margin, objectWidth, objectHeight, object


	drawObject = (x, y, width, height, object) ->
		colorIndex = if object.index > 4 then object.index - 5 else object.index

		drawRoundedRect x, y, width, height, Sequenced.COLOR_OBJECT[colorIndex], 5

		drawWrapText object.name, x + objectWidth / 2, y + (objectHeight) / 2 + fontSize / 3, objectWidth - 10, false

		drawLifeline x + objectWidth / 2, y + objectHeight,  columHeight

	drawLifeline = (x, y, height) ->
		gradient = ctx.createLinearGradient(0, 0, 0, canvasElement.height - Margin * 2);
		gradient.addColorStop(0, "white");
		gradient.addColorStop(1, "steelblue");

		ctx.beginPath()
		ctx.moveTo x, y
		ctx.lineTo x, y + height
		ctx.setLineDash [LifelineWidth * 2, LifelineWidth]
		ctx.lineDashOffset = LifelineWidth * 2
		ctx.strokeStyle = gradient
		ctx.lineWidth = LifelineWidth
		ctx.stroke()
		ctx.setLineDash [1, 0]

	drawMessages = ->
		drawMessage message for message in sequenceData.messages

	drawMessage = (message) ->

	initSequenceData = ->
		# Initialize object index.
		objectIndex = 0

		for object in sequenceData.objects
			object.index = objectIndex++

		# Initialize max row count.
		maxRow = 1

		for message in sequenceData.messages
			maxRow = message.row if message.row > maxRow

		sequenceData.maxRow = maxRow

	initCanvas = ->
		columHeight = RowHeight * ((sequenceData.maxRow + 1) * 2 + 1)

		width = parseInt canvasElement.width
		scaleWidth = width * 2
		height = (columHeight + Margin * 2) / DefaultCanvasWidth * width
		scaleHeight = height * 2

		canvasElement.style.width = width + 'px'
		canvasElement.style.height = height + 'px'
		canvasElement.width = scaleWidth
		canvasElement.height = scaleHeight

		scale = scaleWidth / DefaultCanvasWidth

		ctx = canvasElement.getContext '2d'
		ctx.scale scale, scale

	initVariables = ->
		objectWidth =  if objectWidth is null
		objectHeight = 40 if objectHeight is null
		textLineHeight = 18 if textLineHeight is null
		fontFamily = 'Verdana' if fontFamily is null
		fontColor = '#000' if fontColor is null
		fontSize = 14 if fontSize is null

		#Sequenced.setColor 'message', Sequenced.COLOR_ORANGE, Sequenced.COLOR_ORANGE_BORDER



	getMaxRow = ->
		maxRow = 1

		for message in sequenceData.messages
			maxRow = message.row if message.row > maxRow

		return maxRow

	@drawSystems = ->
		for i in [0...systemCount]
			drawRect getColumnPositionX(i), Margin, systemColumnWidth, columHeight, getColor(sequenceData.systems[i].color), getColor(sequenceData.systems[i].color + '_border')

			drawWrapText sequenceData.systems[i].name, getColumnPositionX(i) + systemColumnWidth / 2, arrowHandleHeight + fontSize / 3, systemColumnWidth

	@drawProcesses = ->
		for processId in [0...sequenceData.processes.length]
			drawProcess processId

	clearProcesses = (canvasElement)->
		ctx.clearRect 0, 0, canvasElement.width, canvasElement.height


	drawProcess = (processId)->
		process = sequenceData.processes[processId]

		fromSystemIndex = getSystemIndex process.from
		toSystemIndex = getSystemIndex process.to

		y = arrowHandleHeight * 3 + arrowHandleHeight * 2.5 * (process.sequence - 1)

		if process.from is process.to
			x1 = getColumnPositionX(fromSystemIndex)
			x2 = getColumnPositionX(toSystemIndex) + systemColumnWidth
		else
			if process.direction is 'right'
				x1 = getColumnPositionX(fromSystemIndex) + systemColumnWidth
				x2 = getColumnPositionX(toSystemIndex)
			else
				x1 = getColumnPositionX(toSystemIndex) + systemColumnWidth
				x2 = getColumnPositionX(fromSystemIndex)

		if process.color is undefined
			process.color = if process.from is process.to then 'action' else 'message'

		color = getColor process.color
		borderColor = getColor process.color + '_border'

		if process.direction is 'right'
			drawRightArrow x1 + 2, x2 - 2, y, color, borderColor, fontColor, process.text
		else
			drawLeftArrow x1 + 2, x2 - 2, y, color, borderColor, fontColor, process.text


	getColumnPositionX = (systemIndex) ->
		Margin + (DefaultCanvasWidth - systemColumnWidth - Margin * 2) / (systemCount - 1) * systemIndex

	getColor = (colorName) ->
		return Sequenced.COLOR_GRAY if colorName is undefined

		color = colorTable[colorName]

		if color is undefined then colorName else color
