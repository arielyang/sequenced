// Generated by CoffeeScript 1.7.1
var CanvasHelper, DefinationParser, Sequenced;

Sequenced = (function() {
  var COLOR_LIFELINE, COLOR_MESSAGE, COLOR_OBJECT_BORDER, DefaultCanvasWidth, DefaultFontColor, DefaultFontFamily, DefaultFontSize, DefaultObjectHeight, DefaultObjectWidth, DefualtLineHeight, Margin, MaxObjectWidth, RowHeight, canvasElement, columHeight, ctx, drawMessage, drawMessages, drawObject, drawObjects, fontColor, fontFamily, fontSize, initCanvas, initSequenceData, initVariables, lineHeight, objectHeight, objectWidth, sequenceData;

  function Sequenced() {}

  ctx = null;

  objectWidth = null;

  objectHeight = null;

  lineHeight = null;

  fontFamily = null;

  fontColor = null;

  fontSize = null;

  canvasElement = null;

  sequenceData = null;

  columHeight = null;

  COLOR_OBJECT_BORDER = '#c0c0c0';

  COLOR_LIFELINE = '#80aada';

  COLOR_MESSAGE = '#f7ab42';

  DefaultCanvasWidth = 800;

  DefaultObjectWidth = 120;

  DefaultObjectHeight = 50;

  DefualtLineHeight = 18;

  DefaultFontFamily = 'Verdana';

  DefaultFontColor = '#000';

  DefaultFontSize = 14;

  MaxObjectWidth = 150;

  RowHeight = 50;

  Margin = 10;

  Sequenced.COLOR_OBJECT = ['#fdd9b4', '#bae0ec', '#c2e2c7', '#c9d1f7', '#e5cff4', '#f8cdd4'];

  Sequenced.render = function(canvasElementId) {
    canvasElement = document.getElementById(canvasElementId);
    sequenceData = DefinationParser.getSequenceData(canvasElement);
    initCanvas();
    initVariables();
    drawObjects();
    return drawMessages();
  };

  Sequenced.setLineHeight = function(height) {
    return lineHeight = height;
  };

  Sequenced.setObjectSize = function(width, height) {
    objectWidth = width;
    return objectHeight = height;
  };

  Sequenced.setFontFamily = function(value) {
    return fontFamily = value;
  };

  Sequenced.setFontColor = function(value) {
    return fontColor = value;
  };

  Sequenced.setFontSize = function(value) {
    return fontSize = value;
  };

  initSequenceData = function() {
    var maxRow, message, object, objectDictionary, objectIndex, _i, _j, _len, _len1, _ref, _ref1;
    objectIndex = 0;
    objectDictionary = {};
    _ref = sequenceData.objects;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      object.index = objectIndex++;
      objectDictionary[object.id] = object.index;
    }
    maxRow = 1;
    _ref1 = sequenceData.messages;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      message = _ref1[_j];
      message.fromObjectIndex = objectDictionary[message.from];
      message.toObjectIndex = objectDictionary[message.to];
      if (message.row > maxRow) {
        maxRow = message.row;
      }
    }
    return sequenceData.maxRow = maxRow;
  };

  initCanvas = function() {
    var height, scale, scaleHeight, scaleWidth, width;
    columHeight = RowHeight * (sequenceData.maxRow + 1.5);
    width = parseInt(canvasElement.width);
    height = (columHeight + Margin * 2) / DefaultCanvasWidth * width;
    scaleWidth = width * 2;
    scaleHeight = height * 2;
    scale = scaleWidth / DefaultCanvasWidth;
    canvasElement.style.width = width + 'px';
    canvasElement.style.height = height + 'px';
    canvasElement.width = scaleWidth;
    canvasElement.height = scaleHeight;
    ctx = canvasElement.getContext('2d');
    return ctx.scale(scale, scale);
  };

  initVariables = function() {
    if (objectWidth === null) {
      objectWidth = DefaultObjectWidth;
    }
    if (objectHeight === null) {
      objectHeight = DefaultObjectHeight;
    }
    if (lineHeight === null) {
      lineHeight = DefualtLineHeight;
    }
    if (fontFamily === null) {
      fontFamily = DefaultFontFamily;
    }
    if (fontColor === null) {
      fontColor = DefaultFontColor;
    }
    if (fontSize === null) {
      return fontSize = DefaultFontSize;
    }
  };

  drawObjects = function() {
    var index, objectKey, x, y, _results;
    index = 0;
    _results = [];
    for (objectKey in sequenceData.objects) {
      x = Margin + (DefaultCanvasWidth - objectWidth - Margin * 2) / (sequenceData.objectCount - 1) * index++;
      y = Margin;
      _results.push(drawObject(x, y, objectWidth, objectHeight, objectKey, sequenceData.objects[objectKey]));
    }
    return _results;
  };

  drawObject = function(x, y, width, height, objectName, objectIndex) {
    var getObjectColor;
    getObjectColor = function(index) {
      var colorIndex;
      colorIndex = index > 5 ? index - 6 : index;
      return Sequenced.COLOR_OBJECT[colorIndex];
    };
    CanvasHelper.drawLifeline(ctx, x + objectWidth / 2, y + objectHeight, canvasElement.height / 2 - Margin * 2 - objectHeight, '#fff', COLOR_LIFELINE);
    CanvasHelper.drawRoundedRect(ctx, x, y, width, height, getObjectColor(objectIndex), COLOR_OBJECT_BORDER, 5);
    return CanvasHelper.drawWrapText(ctx, objectName, x + objectWidth / 2, y + objectHeight / 2 + fontSize / 3, objectWidth - 10, 'bold', fontSize, fontColor, fontFamily);
  };

  drawMessages = function() {
    var message, _i, _len, _ref;
    _ref = sequenceData.messages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      message = _ref[_i];
      drawMessage(message);
    }
    return console.log(sequenceData.messages);
  };

  drawMessage = function(message) {
    var getColumnPositionX, x, x1, x2, y;
    getColumnPositionX = function(objectIndex) {
      return Margin + objectWidth / 2 + (DefaultCanvasWidth - objectWidth - Margin * 2) / (sequenceData.objectCount - 1) * objectIndex;
    };
    y = RowHeight * (message.row + 1);
    switch (message.direction) {
      case 'self':
        x = getColumnPositionX(message.fromObjectIndex);
        return CanvasHelper.drawSelfArrow(ctx, x, y, COLOR_MESSAGE, fontSize, fontColor, fontFamily, message.text, message.isDashed);
      case 'right':
        x1 = getColumnPositionX(message.fromObjectIndex);
        x2 = getColumnPositionX(message.toObjectIndex);
        return CanvasHelper.drawRightArrow(ctx, x1, x2, y, COLOR_MESSAGE, fontSize, fontColor, fontFamily, message.text, message.isDashed);
      case 'left':
        x1 = getColumnPositionX(message.toObjectIndex);
        x2 = getColumnPositionX(message.fromObjectIndex);
        return CanvasHelper.drawLeftArrow(ctx, x1, x2, y, COLOR_MESSAGE, fontSize, fontColor, fontFamily, message.text, message.isDashed);
    }
  };

  return Sequenced;

})();

CanvasHelper = (function() {
  var ActivationWidth, ArrowHandleHeight, LifelineWidth, RowHeight;

  function CanvasHelper() {}

  LifelineWidth = 8;

  ActivationWidth = 12;

  ArrowHandleHeight = 8;

  RowHeight = 50;

  CanvasHelper.drawRect = function(ctx, x, y, width, height, color) {
    ctx.rect(x, y, width, height);
    ctx.fillStyle = color;
    return ctx.fill();
  };

  CanvasHelper.drawRoundedRect = function(ctx, x, y, width, height, color, borderColor, radius) {
    x += 0.5;
    y += 0.5;
    ctx.beginPath();
    ctx.arc(x + radius, y + radius, radius, Math.PI, 1.5 * Math.PI);
    ctx.lineTo(x + width - 2 * radius, y);
    ctx.arc(x + width - radius, y + radius, radius, 1.5 * Math.PI, 2 * Math.PI);
    ctx.lineTo(x + width, y + height - radius);
    ctx.arc(x + width - radius, y + height - radius, radius, 0, 0.5 * Math.PI);
    ctx.lineTo(x + radius, y + height);
    ctx.arc(x + radius, y + height - radius, radius, 0.5 * Math.PI, Math.PI);
    ctx.lineTo(x, y + radius);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = borderColor;
    return ctx.stroke();
  };

  CanvasHelper.drawRightArrow = function(ctx, x1, x2, y, color, fontSize, fontColor, fontFamily, text, isDashed) {
    if (isDashed) {
      ctx.setLineDash([ArrowHandleHeight, ArrowHandleHeight]);
    } else {
      ctx.setLineDash([1, 0]);
    }
    x1 = x1 + ActivationWidth - LifelineWidth / 2;
    x2 = x2 - ActivationWidth + LifelineWidth / 2;
    ctx.beginPath();
    ctx.moveTo(x2 - ArrowHandleHeight, y);
    ctx.lineTo(x1, y);
    ctx.lineDashOffset = ArrowHandleHeight / 3;
    ctx.strokeStyle = color;
    ctx.lineWidth = ArrowHandleHeight;
    ctx.stroke();
    ctx.setLineDash([1, 0]);
    ctx.beginPath();
    ctx.moveTo(x2 - ArrowHandleHeight, y - ArrowHandleHeight);
    ctx.lineTo(x2, y);
    ctx.lineTo(x2 - ArrowHandleHeight, y + ArrowHandleHeight);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    return this.drawWrapText(ctx, text, (x1 + x2) / 2, y - fontSize, x2 - x1 - fontSize, 'normal', fontSize, fontColor, fontFamily);
  };

  CanvasHelper.drawLeftArrow = function(ctx, x1, x2, y, color, fontSize, fontColor, fontFamily, text, isDashed) {
    if (isDashed) {
      ctx.setLineDash([ArrowHandleHeight, ArrowHandleHeight]);
    } else {
      ctx.setLineDash([1, 0]);
    }
    x1 = x1 + ActivationWidth - LifelineWidth / 2;
    x2 = x2 - ActivationWidth + LifelineWidth / 2;
    ctx.beginPath();
    ctx.moveTo(x1 + ArrowHandleHeight, y);
    ctx.lineTo(x2, y);
    ctx.lineDashOffset = ArrowHandleHeight / 3;
    ctx.strokeStyle = color;
    ctx.lineWidth = ArrowHandleHeight;
    ctx.stroke();
    ctx.setLineDash([1, 0]);
    ctx.beginPath();
    ctx.lineTo(x1 + ArrowHandleHeight, y - ArrowHandleHeight);
    ctx.lineTo(x1, y);
    ctx.lineTo(x1 + ArrowHandleHeight, y + ArrowHandleHeight);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    return this.drawWrapText(ctx, text, (x1 + x2) / 2, y - fontSize, x2 - x1 - fontSize, 'normal', fontSize, fontColor, fontFamily);
  };

  CanvasHelper.drawSelfArrow = function(ctx, x, y, color, fontSize, fontColor, fontFamily, text, isDashed) {
    var radius, y1, y2;
    if (isDashed) {
      ctx.setLineDash([ArrowHandleHeight, ArrowHandleHeight]);
    } else {
      ctx.setLineDash([1, 0]);
    }
    x = x + ActivationWidth - LifelineWidth / 2;
    y1 = y - RowHeight / 2;
    y2 = y + RowHeight / 2;
    radius = RowHeight / 2;
    ctx.beginPath();
    ctx.moveTo(x, y1);
    ctx.lineTo(x + ArrowHandleHeight, y1);
    ctx.arc(x + ArrowHandleHeight, y1 + radius, radius, 1.5 * Math.PI, 0.5 * Math.PI, false);
    ctx.lineDashOffset = -0.5;
    ctx.strokeStyle = color;
    ctx.lineWidth = ArrowHandleHeight;
    ctx.stroke();
    ctx.setLineDash([1, 0]);
    ctx.beginPath();
    ctx.lineTo(x + ArrowHandleHeight, y2 - ArrowHandleHeight);
    ctx.lineTo(x, y2);
    ctx.lineTo(x + ArrowHandleHeight, y2 + ArrowHandleHeight);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    return this.drawWrapText(ctx, text, x + ArrowHandleHeight * 2 + radius, y + fontSize / 2, 200 - fontSize, 'normal', fontSize, fontColor, fontFamily, 'left');
  };

  CanvasHelper.drawLifeline = function(ctx, x, y, height, startColor, stopColor) {
    var gradient;
    gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, startColor);
    gradient.addColorStop(1, stopColor);
    ctx.beginPath();
    ctx.moveTo(x, y + height);
    ctx.lineTo(x, y);
    ctx.setLineDash([LifelineWidth * 2, LifelineWidth]);
    ctx.strokeStyle = gradient;
    ctx.lineWidth = LifelineWidth;
    ctx.stroke();
    return ctx.setLineDash([1, 0]);
  };

  CanvasHelper.drawWrapText = function(ctx, text, x, y, maxWidth, fontWeight, fontSize, fontColor, fontFamily, textAlign) {
    var i, line, lineHeight, metrics, testLine, testWidth, words, yd, _i, _ref;
    ctx.font = "" + fontWeight + " " + fontSize + "px " + fontFamily;
    ctx.textAlign = textAlign ? textAlign : 'center';
    ctx.fillStyle = fontColor;
    x += 4;
    words = text.split(' ');
    line = '';
    yd = 0;
    lineHeight = fontSize * 1.2;
    for (i = _i = 0, _ref = words.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      testLine = line + words[i] + ' ';
      metrics = ctx.measureText(testLine);
      testWidth = metrics.width;
      if (testWidth > maxWidth && i > 0) {
        yd = fontSize / 2 + 2;
        ctx.fillText(line, x, y - yd);
        line = words[i] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    return ctx.fillText(line, x, y - yd);
  };

  return CanvasHelper;

})();

DefinationParser = (function() {
  function DefinationParser() {}

  DefinationParser.getSequenceData = function(element) {
    var direction, fromObjectIndex, getInnerText, innerText, match, messageType, objectFrom, objectIndex, objectTo, preMessage, regex, row, sequenceData, text, toObjectIndex;
    getInnerText = function(element) {
      if (element.childNodes.length === 0) {
        return '';
      } else {
        return element.childNodes[0].nodeValue;
      }
    };
    regex = /(.+\b)\s*(-->|->|<--|<-)\s*(.+\b)\s*:\s*(.+)\n?/gm;
    sequenceData = {
      objects: {},
      objectCount: 0,
      messages: [],
      maxRow: 0
    };
    innerText = getInnerText(element);
    objectIndex = 0;
    while (match = regex.exec(innerText)) {
      objectFrom = match[1].trim();
      messageType = match[2].trim();
      objectTo = match[3].trim();
      text = match[4].trim();
      if (objectFrom === objectTo) {
        direction = 'self';
      } else if (messageType[0] === '<') {
        direction = 'left';
      } else {
        direction = 'right';
      }
      if (sequenceData.objects[objectFrom] === void 0) {
        sequenceData.objects[objectFrom] = objectIndex;
        objectIndex++;
      }
      if (sequenceData.objects[objectTo] === void 0) {
        sequenceData.objects[objectTo] = objectIndex;
        objectIndex++;
      }
      fromObjectIndex = sequenceData.objects[objectFrom];
      toObjectIndex = sequenceData.objects[objectTo];
      if (sequenceData.messages.length === 0) {
        row = 1;
      } else {
        preMessage = sequenceData.messages[sequenceData.messages.length - 1];
        if (preMessage.direction === 'self') {
          row = preMessage.row + 2;
        } else if (fromObjectIndex === preMessage.toObjectIndex && direction === preMessage.direction) {
          row = preMessage.row;
        } else {
          row = preMessage.row + 1;
        }
      }
      sequenceData.messages.push({
        'text': text,
        'direction': direction,
        'fromObjectIndex': fromObjectIndex,
        'toObjectIndex': toObjectIndex,
        'isDashed': /--/.test(messageType),
        'row': row
      });
      sequenceData.objectCount = objectIndex;
      sequenceData.maxRow = row;
    }
    return sequenceData;
  };

  return DefinationParser;

})();
